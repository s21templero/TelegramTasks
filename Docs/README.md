# Проект TelegramTasks - техническое задание

## 1. Общее описание
Проект должен представлять собой сервис для работы с задачами (task manager), интегрированный с Telegram Bot. Заложить так же возможность интеграции с Telegram Mini App и отдельным Web App с авторизацией через Telegram Login. Внутреннее взаимодействие организовать по протоколу gRPC, взаимодействие с внешними сервисами по REST API.

## 2. Процесс взаимодействия
Пользователь авторизуется в боте, написав ему первое сообщение, далее командами создаёт, удаляет существующие задачи, переключается между ними. 

Задача представляет собой список (действий), каждое из которых может быть выполненым или нет. У задачи может быть 1 родительская и много дочерних задач.

Для отметки задания выполненным можно использовать (2 варианта реализации):
  1. Telegram Polling (голосование, с множеством вариантов ответа) - **предпочтительный**
  2. Telegram Bot Button (кнопки) 

При выполнении родительской задачи - дочерние задачи больше не могут быть выполнены

При выполнении всех дочерних задач - родительской задаче должен быть так же установлен статус "выполнена"

После создания таски пользователь получает её идентификатор, который может передать другим пользователям (через личные сообщения, не функционал бота). Другие пользователи могут, переключившись в боте на эту задачу, выполнять те же действия что и администратор задачи, кроме удаления.

У каждого пользователя есть лимит в `10` задач, при достижении данного лимита возможно 2 варианта реализации:
  1. переключение на новую активную задачу автоматически убирает подписку на самую старую активную задачу (об этом необходимо предупредить пользователя и дать ему возможность выбора оставить ли старую задачу, или добавить новую)
  2. переключение на новую активную задачу невозможно пока пользователь не выйдет из старой (просто выдать ошибку) - **менее оптимальный**

Если от задачи отписался последний пользователь - она автоматически удаляется. Если от задачи отписался её создатель - она автоматически переходит во владение пользователю, который дольше остальных был на неё подписан.

При изменении статуса всей задачи или её подзадач необходимо оповещать об этом всех участников (через сообщение в боте). 

Задачи хранятся не более **`12` месяцев**, лимит активных задач на пользователя: `10` (брать из конфигурационного файла / переменных окружения). 

После выполнения всех пунктов задача автоматически удаляется через `t` времени (брать из конфигурационного файла / переменных окружения)

Очистка неактивных пользователей производится раз в **`6` месяцев**. Все задачи неактивных пользователей удаляются.

## 3. Бот
Должен представлять собой текстового бота, принимающего от пользователя команды, валидирующего их и передающего на Backend API. Хранение учётных данных пользователей на стороне бота не предусмотрено, всё взаимодействие с учётными данными производить на стороне API. Сфера ответственности:
  - Работа с входящими сообщениями от пользователей, их первичная валидация
  - Работа с действиями пользователей (нажатие кнопок, голосование), первичная валидация действий
  - Хранение в кэше (внешнем) JWT токенов, выданых KeyCloack, для активных пользователей
  - *(при необходимости) Хранение в кэше (внешнем) и базе данных id сессий (чатов) для активных пользователей*
  - Передача информации о действиях пользователей на бэкэнд
  - Получение от бэкэнда, обработка и передача пользователям сообщений о результатах действий / обновление пользовательского интерфейса

## 4. Backend API
Должно представлять собой приложение, работающее с протоколами REST API, gRPC - для взаимодействия с ботом. Приложение должно быть интегрировано с KeyCloack. Взаимодействие с базой данных предусмотреть через Entity Framework Core, используемые данные кэшировать. В схеме взаимодействия между сервисами предусмотреть брокер сообщений. Сфера ответственности:
  - Логика взаимодействия с профилями пользователей
  - Логика взаимодействия с задачами
  - Логика взаимодействия с подключёнными к системе ботами (и информацией о них)
  - Валидация JWT токенов
  - Взаимодействие с базой данных для хранения информации о профилях, задачах, ботах
  - Кэширование используемых данных
  - Взаимодействие с внешними сервисами (REST API)
  - Взаимодействие с внутренними сервисами ботов (gRPC)

## 5. Frontend Telegram Mini App
(Предусмотреть саму возможность дальнейшей реализации) Должен представлять собой Single Page Application с теми же возможностями, что и у Telegram Chat Bot, но с более удобным интерфейсом и красивым визуальным отображением сущностей.

## 6. Общая схема
[![Скриншот руководства](./02.%20TelegramTasksProjectDiagram.drawio.png)](./02.%20TelegramTasksProjectDiagram.drawio.pdf)
*Нажмите для просмотра полного PDF-документа*

## 7. Отношение сущностей
![Entity Relationship Diagram](./01.%20Entity%20Relationship%20Diagram.PNG)
- **7.1. User** 

  Таблица `UserData` должна содержать поля:
  - id - уникальный идентификатор пользователя
  - nickname - ник пользователя в системе
  - firstname - имя пользователя
  - lastname - фамилия пользователя
  - username - ник пользователя в телеграм
  - bot_id - идентификатор бота, который зарегистрировал пользователя (внешний ключ от `id` бота в таблице `BotData`)
  - last_active - временная метка последней активности пользователя
  - reg_date - временная метка регистрации пользователя
- **7.2. Task**

  Таблица `TaskData` должна содержать поля:
  - id - уникальный идентификатор задачи
  - title - заголовок задачи
  - description - описание задачи
  - parent - родительская задача (внешний ключ от `task_parent` в таблице `TaskFamily`)
  - children - дочерние задачи (внешний ключ от `task_child` в таблице `TaskFamily`)
  - due_time - временная метка окончания задачи (дедлайн)
  - creation_date - временная метка создания задачи
  - is_complete - флаг состояния задачи (завершена/не завершена)
- **7.3. BotData**

  Таблица `BotData` должна содержать поля:
  - id - уникальный идентификатор бота
  - name - имя бота
  - version - версия api бота
  - owner - владелец бота (внешний ключ от `id` в таблице `UserData`)
  - is_active - флаг наличия у бота действующего доступа к системе
- **7.4. Многие-ко-многим `UserData.id`<->`TaskData.id`**

  Таблица `UserTask` должна содержать поля:
  - user_id - идентификатор пользователя (внешний ключ от `id` в таблице `UserData`)
  - task_id - идентификатор задачи (внешний ключ от `id` в таблице `TaskData`)
  - assigned_at - временная метка добавления пользователя/задачи
  - is_owner - является ли пользователь владельцем задачи
  - status - дополнительное поле статуса пользователя в задаче
  Поля `user_id` и `task_id` должны формировать составной первичный ключ для таблицы
- **7.5. Многие-ко-многим `TaskData.id`<->`TaskData.children`, связь `TaskData.parent`**

  Таблица `TaskFamily` должна содержать поля:
  - task_parent - идентификатор родительской задачи (внешний ключ `id` в таблице `TaskData`)
  - task_child - идентификатор дочерней задачи (внешний ключ `id` в таблице `TaskData`)

## 8. Слои, взаимодействие
- **8.1. TelegramTasks.Bot**

  (no diagram yet)

- **8.2. TelegramTasks.API** 
![Picture](./03.%20Unit%20Relationship%20Diagram.drawio.png)

- **8.3. TelegramTasks.Frontend**

  (no diagram yet)